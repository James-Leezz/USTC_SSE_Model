<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/305825 (zh-CN, DDL); Windows/6.1.7601 Service Pack 1 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="335"/>

<div>
<span><div><div><div><div><div><div style="text-align: center;"><span style="font-weight: bold;"><font style="font-size: 18pt;"><br/></font></span></div><div style="text-align: center;"><span style="font-weight: bold;"><font style="font-size: 18pt;">建模复习——从入门到放弃</font></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;"><br/></span></span></div><div style="text-align: center;"><font style="font-size: 12pt;"><span style="line-height: 23px;">17 网络与信息安全     雷杨</span></font></div><div style="text-align: center;"><font style="font-size: 12pt;"><span style="line-height: 23px;"><br/></span></font></div><div style="text-align: center;"><font style="font-size: 12pt;"><span style="line-height: 23px;"><br/></span></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">1 . CPS系统 </span><span style="font-size: 12pt; font-weight: bold;">(</span><span style="font-size: 12pt; font-weight: bold;">Cyber-Physical Systems)</span></span></div><div><br/></div><div><br/></div><div><span style="font-weight: bold; line-height: 1.45;">参考资料：</span></div><ul><li><span style="line-height: 1.45;">introduction.ppt （p1~p33）</span></li><li><a href="http://www.baike.com/wiki/%E4%BF%A1%E6%81%AF%E7%89%A9%E7%90%86%E8%9E%8D%E5%90%88%E7%B3%BB%E7%BB%9F" style="font-style: italic;">信息物理融合系统</a></li></ul><div><br/></div><div><br/></div><div><span style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold;">1.1 CPS系统概述</span></span></div><div><span style="font-size: 10pt; line-height: 1.45;">     Cyber（</span><span style="font-size: 10pt; line-height: 1.45;">信息技术</span><span style="font-size: 10pt; line-height: 1.45;">）:  计算，通信，控制（3C技术,computation,communication, control )，并且离散，逻辑，交换的系统；</span></div><div><span style="font-size: 10pt; line-height: 1.45;">     Physical（</span><span style="font-size: 10pt; line-height: 1.45;">物理系统</span><span style="font-size: 10pt; line-height: 1.45;">）： 自然的和人造的系统受物理定律的支配，并持续运行；</span></div><div><span style="font-size: 10pt; line-height: 1.45;">     Cyber-Physical Systems</span><span style="font-size: 10pt; color: rgb(227, 0, 0); line-height: 1.45;">（</span><span style="font-size: 10pt; line-height: 1.45;">信息物理融合系统</span><span style="font-size: 10pt; color: rgb(227, 0, 0); line-height: 1.45;">）</span><span style="font-size: 10pt; line-height: 1.45;">:  网络和物理系统紧密结合在一起的系统。</span></div><div><br/></div><div><span style="font-weight: bold; line-height: 19px;">1.2 CPS系统的特点</span></div><div><ul><li><span style="line-height: 19px;">信息-物理的耦合由新的需求和应用驱动</span></li></ul><div><span style="line-height: 1.45;">                网络工作在多个和极端的规模下，每个物理组件中的网络性能，大规模的有线和无线网络  </span></div><ul><li>系统的系统</li><li>新的时空约束</li></ul><div>                多个时间和空间尺度上的复杂性，动态重组/重新配置，非传统的计算和物理基板</div></div><div><ul><li>通信/计算/控制 之间的新型交互</li></ul><div>                自动化程度高，控制回路必须在所有尺度上关闭，<span style="line-height: 1.45;">控制回路中有大量非技术型的精明用户</span></div></div><div><ul><li>无处不在的安全和隐私需求，操作必须可靠</li></ul><div><br/></div></div><div><span style="line-height: 1.45;">         Notice：</span><span style="line-height: 1.45;">不是桌面计算；</span><span style="line-height: 1.45;">不是传统的，事后嵌入式/实时系统；</span><span style="line-height: 1.45;">不是今天的传感器网络。其研究目标是物理和网络（计算，通信，控制）设计深度集成。</span></div><div><br/></div><div><span style="font-weight: bold; line-height: 1.45;">1.3 CPS系统的应用领域</span></div><div><ul><li>防御系统</li><li>远程物理操作（如：<span style="line-height: 1.45;">远程医疗，</span><span style="line-height: 1.45;">远程操控</span>）</li></ul><div><br/></div></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">2. 模型驱动开发 </span><span style="font-size: 12pt; font-weight: bold;">( MDD,Model-Driven Development )</span></div><div><br/></div><div><span style="font-weight: bold; line-height: 1.45;">参考资料</span></div><div><ul><li><span style="line-height: 1.45;">introduction.ppt （p34~p47）</span></li><li><a href="http://www.zhoujingen.cn/blog/2749.html" style="font-style: italic;">MDSF：模型驱动开发（MDD）介绍</a></li><li><a href="http://blog.sina.com.cn/s/blog_8077b6d901012iyf.html" style="font-style: italic;">元模型</a></li></ul><div><br/></div></div><div><br/></div><div><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold;">2.1 模型</span></font></div><blockquote style="margin: 0px 0px 0px 40px; border: none; padding: 0px;"><div><span style="font-size: 10pt;">是指某个系统的简化/抽象表示，从给定的角度突出显示感兴趣的属性。</span><span style="font-size: 10pt; line-height: 1.45;">这个观点定义了模型的关注和范围</span><span style="font-size: 12pt; line-height: 1.45;">。</span></div><div style="text-align: center;"><img src="建模复习——从入门到放弃_files/Image.png" type="image/png" data-filename="" style="font-size: 12pt;"/></div><div style="text-align: center;"><span style="font-weight: bold;">图2.1-1：系统层次图</span></div></blockquote><div><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold;">2.2  MDA定义的三种模型</span></font></div><div><ul><li><span style="line-height: 19px;">计算独立模型（</span><span style="line-height: 19px;">CIM，</span><span style="line-height: 19px;">Computation-Independent Model）</span></li></ul></div><blockquote style="margin: 0px 0px 0px 40px; border: none; padding: 0px;"><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">描述系统的需求和将在其中使用系统的业务上下文</span></span>。此模型通常描述系统将用于做什么，而不描述如何实现系统。CIM 通常用业务语言或领域特定语言来表示。</div><div><br/></div></blockquote><div><ul><li><span style="line-height: 19px;">平台独立模型（</span><span style="line-height: 19px;">PIM，</span><span style="line-height: 19px;">Platform-Independent Model）</span></li></ul></div><blockquote style="margin: 0px 0px 0px 40px; border: none; padding: 0px;"><div><span style="line-height: 19px;"><span style="background-color: rgb(255, 250, 165); line-height: 19px;-evernote-highlight:true;">描述如何构造系统</span>，而不涉及到用于实现模型的技术。此模型不描述用于为特定平台构建解决方案的机制。PIM 在由特定平台实现时可能是适当的，或者可能适合于多种平台上的实现。</span></div><div><br/></div></blockquote><div><ul><li><span style="line-height: 19px;">平台特定模型 （</span><span style="line-height: 19px;">PSM，</span><span style="line-height: 19px;">Platform-Specific Model）</span></li></ul></div><blockquote style="margin: 0px 0px 0px 40px; border: none; padding: 0px;"><div><span style="line-height: 19px;">从特定平台的角度描述解决方案。</span><span style="background-color: rgb(255, 250, 165); line-height: 19px;-evernote-highlight:true;">其中包括如何实现 CIM 和如何在特定平台上完成该实现的细节</span><span style="line-height: 19px;">。</span></div></blockquote><div><br/></div><div><span style="font-size: 10pt; font-weight: bold; line-height: 23px;">2.3</span> <span style="font-size: 10pt; font-weight: bold; line-height: 23px;">模型驱动层次结构</span></div><div><br/></div><div style="text-align: center;"><img src="建模复习——从入门到放弃_files/Image [1].png" type="image/png" data-filename=""/></div><div style="text-align: center;">    图2.3-1：模型驱动开发途径</div><div style="text-align: center;"><br/></div><div style="text-align: center;"><br/></div><div style="text-align: center;"><br/></div><div style="text-align: center;"><div>                 <img src="建模复习——从入门到放弃_files/Image [2].png" type="image/png" data-filename="" width="316"/></div></div><div style="text-align: center;">                                    </div><div style="text-align: center;">                图2.3-2：模型驱动<span style="line-height: 1.45;">层次结构（1）</span></div><div style="text-align: left;"><div><br/></div></div><div style="text-align: left;"><div><br/></div></div><div style="text-align: center;"><div><span style="line-height: 1.45;">             <img src="建模复习——从入门到放弃_files/Image [3].png" type="image/png" data-filename="" width="435"/></span></div></div><div style="text-align: center;"><div><span style="line-height: 1.45;">                  图2.3-3：模型驱动<span style="line-height: 1.45;">层次结构（2）</span></span></div></div><div style="text-align: left;"><br/></div><div style="text-align: left;"><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">3 . 安全悠关系统与实时系统（</span><span style="font-size: 12pt; font-weight: bold;">Safety-Critcal Systems and Real-Time Systems</span><span style="font-size: 12pt; font-weight: bold;">）</span></div><div><br/></div><div><span style="font-size: 10pt; font-weight: bold;">参考资料：</span></div><div><ul><li><span style="line-height: 19px;">safety-critical system.ppt（p1~p36）</span></li><li><a href="http://blog.csdn.net/abigale1011/article/details/6450845/" style="font-style: italic; line-height: 19px;">死锁和死锁处理</a></li></ul><div><br/></div></div><div><br/></div><div><span style="font-size: 10pt; font-weight: bold;">3.1 实时系统（Real-Time Systems）的定义</span></div><div><span style="font-size: 10pt; font-weight: bold;">        </span><span style="font-size: 10pt;">系统的正确性不仅取决于计算的逻辑结果，还取决于产生结果的时间。</span></div><div><br/></div><div><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold;">3.2 设计过程（The Design Process）</span></font></div><div><ul><li><span style="line-height: 19px;">建模（Modeling）：建模是通过模型获得对系统更深层次的理解的过程。 模型模拟系统并反映系统的属性。 模型指定了系统的功能。</span></li><li><span style="line-height: 19px;">设计（Design）：设计是工件的结构化创造过程，它指定了系统如何执行它的功能。</span></li><li><span style="line-height: 19px;">分析（Analysis）：分析是通过“解剖”获得对系统更深入理解的过程。它规定了一个系统为什么会这么做（或者不能做一个模型所要做的事情）</span></li></ul><div><br/></div></div><div><span style="font-weight: bold; line-height: 19px;">3.3 术语和概念</span></div><div><span style="line-height: 19px;">       实时系统（Real-Time System）：</span></div><div><span style="line-height: 19px;">             在计算和操作上具有性能最后期限的系统。 实时系统常常被忽略。意味着计算系统存在于一个更大的系统内部，目的是帮助系统实现其整体职责。</span></div><div><br/></div><div><span style="line-height: 19px;">       事件驱动系统（Event-Driven System）：</span></div><div><span style="line-height: 19px;">             其行为主要是</span><span style="background-color: rgb(255, 250, 165); line-height: 19px;-evernote-highlight:true;">对外部事件的特定反应来驱动</span><span style="line-height: 19px;">而不是自发产生的。</span></div><div><br/></div><div><span style="line-height: 19px;">       时间驱动系统驱动（Time-Driven Systems）:</span></div><div><span style="line-height: 19px;">             其行为主要由</span><span style="background-color: rgb(255, 250, 165); line-height: 19px;-evernote-highlight:true;">时间推移或时间的到来驱动</span><span style="line-height: 19px;">。</span></div><div><span style="line-height: 19px;">      以上为对外部设备的几种响应方式。</span></div><div><br/></div><div style="text-align: center;">          <img src="建模复习——从入门到放弃_files/Image [4].png" type="image/png" data-filename="" width="447"/></div><div style="text-align: center;">                                图3.3-1：事件驱动与时间驱动</div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">3.4 一些定义（Definitions）</span></div><div><br/></div><div><ul><li><span style="font-size: 10pt; line-height: 1.45;">时间约束（Timing constraint）：对执行时间行为的约束（包括硬实时和软实时）</span></li><li><span style="font-size: 10pt; line-height: 1.45;">发布时间（Release Time）：作业变成为可执行的时间。如果所有的工作在系统开始执行时被释放，那么就认为没有释放时间</span></li><li><span style="font-size: 10pt; line-height: 1.45;">截止时间（Deadline）：工作被要求执行完成的时间。如果截止时间是无限的，那么工作就没有最后期限。绝对截止时间等于发布时间加上相对截止时间</span></li><li><span style="font-size: 10pt; line-height: 1.45;">响应时间（Response time）：作业从发布到执行完成的时间长度</span></li></ul><div><br/></div></div><div><span style="font-weight: bold; line-height: 19px;">3.5 实时系统的描述</span></div><div><ul><li><span style="line-height: 19px;"><span style="background-color: rgb(255, 250, 165); line-height: 19px;-evernote-highlight:true;">及时性</span>（timeless）</span></li><li><span style="line-height: 19px;"><span style="background-color: rgb(255, 250, 165); line-height: 19px;-evernote-highlight:true;">并发性</span>（concurrency）</span></li><li><span style="line-height: 19px;"><span style="background-color: rgb(255, 250, 165); line-height: 19px;-evernote-highlight:true;">可预测性</span>（predictability）</span></li><li><span style="line-height: 19px;"><span style="background-color: rgb(255, 250, 165); line-height: 19px;-evernote-highlight:true;">正确性和鲁棒性</span>（correctness and robustness）</span></li></ul><div><br/></div></div><div><span style="line-height: 19px;">    及时性：</span></div><div><span style="line-height: 19px;">    行为的及时性与时间约束有关，如截止时间。最后期限可能很硬或很软。时效性的重要建模问题是建模执行时</span><span style="line-height: 19px;">间，截止时间，到达模式，同步模式和时间源。</span></div><div><br/></div><div><span style="line-height: 19px;">    并发性：</span></div><div><span style="line-height: 19px;">    多个操作顺序链的同时执行。围绕并发系统执行的问题与此有关：</span></div><div><span style="line-height: 19px;">          a.并发线程的调度特性</span></div><div><span style="line-height: 19px;">          b.即将到来的事件的到来模式</span></div><div><span style="line-height: 19px;">          c.线程必须同步时使用的集合点模式</span></div><div><span style="line-height: 19px;">          d.控制对共享资源访问的方法</span></div><div><br/></div><div><span style="line-height: 19px;">    正确性和鲁棒性：</span></div><div><span style="line-height: 19px;">    正确性表明一个系统总是运行正确。鲁棒性表明系统即使在遇到新的情况（不在计划中）下也是可靠的。<span style="background-color: rgb(255, 250, 165); line-height: 19px;-evernote-highlight:true;">因此必须警惕死锁，竞争以及其他异常情况</span></span></div><div><br/></div><div><span style="line-height: 19px;">    <span style="line-height: 19px; font-weight: bold;">死锁，竞争，与异常情况</span></span></div><div><span style="line-height: 19px;">    死锁产生的条件：</span></div><div><ul><li><span style="line-height: 19px;">系统资源不足</span></li><li><span style="line-height: 19px;">任务推进不合理</span></li><li><span style="line-height: 19px;">资源分配不当等</span></li></ul><div><br/></div></div><div><span style="line-height: 19px;">    死锁的四个必要条件</span><span style="line-height: 19px;">：</span></div><div><ul><li><span style="line-height: 19px;"><span style="background-color: rgb(255, 250, 165); line-height: 19px;-evernote-highlight:true;">互斥</span>。任务要求对共享资源进行独占控制，即一个资源每次只能被一个进程使用</span></li><li><span style="line-height: 19px;"><span style="background-color: rgb(255, 250, 165); line-height: 19px;-evernote-highlight:true;">占有且等待</span>。任务在等待其他资源被放弃的同时保持资源，即一个进程因请求资源而阻塞时，对已获得的资源保持不放</span></li><li><span style="line-height: 19px;"><span style="background-color: rgb(255, 250, 165); line-height: 19px;-evernote-highlight:true;">不可剥夺性</span>。任务已获得的资源，在未使用完之前，不能强行剥夺</span></li><li><span style="line-height: 19px;"><span style="background-color: rgb(255, 250, 165); line-height: 19px;-evernote-highlight:true;">循环等待</span>。若干进程之间形成一种头尾相接的循环等待资源关系</span></li></ul><div><br/></div></div><div><span style="line-height: 19px;">    处理死锁的基本方法：</span></div><div><ul><li><span style="line-height: 19px;">死锁预防：破坏死锁的必要条件</span></li><li><span style="line-height: 19px;">死锁避免：允许前三个必要条件，但采取措施避免形成循环等待（如，银行家算法）</span></li><li><span style="line-height: 19px;">死锁检查和死锁解除：系统检查是否存在死锁，若存在，则通过撤销部分进程等方法回收资源，解除死锁</span></li></ul></div><div><span style="line-height: 19px;">    </span></div><div><span style="line-height: 19px;">    否定条件4的方法：</span></div><div><ul><li><span style="line-height: 19px;">信号量机制（如，哲学家进餐问题）</span></li><li><span style="line-height: 19px;">使用定时会合（timed rendezvous）</span></li></ul><div><br/></div></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">4 . 实时系统任务调度（<span style="font-size: 12pt; font-weight: bold;">Real-time workload</span></span><span style="font-size: 12pt; font-weight: bold;">）</span></div><div>    </div><div>    本小结重点内容是实时调度算法，主要包括RM算法（静态优先级）和EDF算法（动态优先级）</div><div><br/></div><div><span style="font-size: 10pt; font-weight: bold;">   参考资料：</span></div><div><ul><li><span style="line-height: 19px;">2.safety-critical system.ppt （p47~p106）</span></li><li><a href="http://blog.csdn.net/thl789/article/details/617629" style="font-style: italic; line-height: 19px;">优先级反转和优先级继承</a></li></ul></div><div><br/></div><div><span style="font-weight: bold;"> 4.1 术语和概念</span></div><div><br/></div><div>      实时工作量</div><div><ul><li><span style="line-height: 1.45;">工作（Job，工作单位）：计算，文件读取，消息传输等</span></li><li><span style="line-height: 1.45;">属性（Attributes）：推进需要的资源，时间参数</span></li></ul></div><div><br/></div><div>      实时任务</div><div>      任务：从读取输入数据和内部状态开始，结束生成结果并更新内部状态。</div><div>      在调用点没有内部状态的任务称为无状态任务，否则称为有状态任务。</div><div><br/></div><div>       对于周期任务（p，e），任务周期性的重复。（注意任务的描述符号表示，调度算法部分会用到）</div><div><ul><li><span style="line-height: 1.45;">周期 p = inter - release time；p&gt;0</span></li><li><span style="line-height: 1.45;">执行时间 e = maximum execution time  (0 &lt; e &lt; p)</span></li><li><span style="line-height: 1.45;">利用率 U = e/p</span></li></ul></div><div><br/></div><div><span style="font-size: 10pt; font-weight: bold;">   </span> <span style="font-size: 10pt;">截止时间：硬截止时间 VS 软截止时间</span></div><div><span style="font-size: 10pt;">     硬截止时间：如果错过了最后期限，可能会造成灾难性的或非常严重的后果</span></div><div>                         因此验证是至关重要的：即使在最坏的情况下，系统运行是否能够满足所有的截止时间</div><div><span style="line-height: 1.45;">                         确定性保证</span></div><div><span style="line-height: 1.45;">     软截止时间：理想情况下，截止时间应该达到最高性能。 在最后期限未到的情况下，性能会下降。</span></div><div><span style="line-height: 1.45;">                        属于尽最大努力保证实时服务一类</span></div><div><br/></div><div>    可调度性：</div><div>    表示实时系统（一组实时任务）是否能够按期完成的属性</div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">4.2 RM（</span><span style="font-weight: bold;">单调速率，<span style="font-weight: bold;">Rate Monotonic</span></span><span style="font-weight: bold;">）调度算法</span></div><div>    </div><div><div>   <span style="font-weight: bold;"> </span><span style="font-weight: bold;">4.2.1 调度算法描述</span></div><ul><li><span style="background-color: rgb(255, 250, 165); line-height: 1.45;-evernote-highlight:true;">最佳的静态优先级调度</span></li><li><span style="line-height: 1.45;">根据周期分配优先权</span></li><li><span style="background-color: rgb(255, 250, 165); line-height: 1.45;-evernote-highlight:true;">周期较短的任务具有较高的优先级</span></li><li><span style="line-height: 1.45;">以最短的时间执行一项工作</span></li></ul><div><br/></div></div><div>    注：</div></div></div><blockquote style="margin: 0px 0px 0px 40px; border: none; padding: 0px;"><div style="text-align: left;"><div><span style="line-height: 1.45;">（1）RM的最优性可以描述为：如果一个任务集能够被静态调度, 那么RM调度算法就能够调度这个任务集。</span></div><div><span style="line-height: 1.45;">        其最最优性可以证明，证明方法类似于动态规划中的“剪贴法”。</span></div><div><span style="line-height: 1.45;">（2）RM调度算法属于“可抢占”式调度一类（事实上，后面的EDF也是这一类）。</span></div><div><br/></div></div></blockquote><div style="text-align: left;"><div><br/></div><div>    <span style="font-weight: bold;">4.2.2 调度过程</span></div><div><span style="font-weight: bold;">        </span></div></div><blockquote style="margin: 0px 0px 0px 40px; border: none; padding: 0px;"><div style="text-align: left;"><div>响应时间<span style="font-weight: bold;">：</span>任务从释放时间到结束时间</div></div></blockquote><div style="text-align: left;"><div><br/></div><div style="text-align: center;"><div><span style="font-weight: bold;">     <img src="建模复习——从入门到放弃_files/Image [5].png" type="image/png" data-filename="" style="font-weight: bold;" width="612"/></span></div></div><div style="text-align: center;">图4.2.2-1：RM调度过程示意图（dealine miss）</div><div style="text-align: center;"><br/></div><div style="text-align: center;"><br/></div><div style="text-align: center;"><div><img src="建模复习——从入门到放弃_files/Image [6].png" type="image/png" data-filename="" width="644"/></div></div><div style="text-align: center;"><br/></div><div style="text-align: center;"><div>图4.2.2-2：RM调度过程示意图（response）</div></div><div style="text-align: left;"><br/></div><div style="text-align: left;"><div>     </div></div><div style="text-align: left;"><div>   <span style="font-weight: bold;"> </span><span style="font-weight: bold;">4.2.3 RM调度模型的前提假设</span></div></div><div style="text-align: left;"><ul><li><span style="line-height: 1.45;">所有的任务是</span><span style="background-color: rgb(255, 250, 165); line-height: 1.45;-evernote-highlight:true;">相互独立</span><span style="line-height: 1.45;">的（例如，它们不相互作用，不相互依赖）</span></li><li><span style="line-height: 1.45;">所有任务都是周期的，且<span style="background-color: rgb(255, 250, 165); line-height: 1.45;-evernote-highlight:true;">运行时间不变</span></span></li><li><span style="line-height: 1.45;">没有任何任务因等待外部事件而阻塞。</span></li><li><span style="line-height: 1.45;">所有任务共享一个共同的释放时间（临界时刻，critical instant）</span></li><li><span style="line-height: 1.45;">所有的任务的截止时间等于它们的周期，即任务必须在下一个作业释放之前完成。</span></li></ul><div><br/></div><div>   <span style="font-weight: bold;"> </span><span style="font-weight: bold;">4.2.4 RM调度模型使用限制</span></div><div>          如果一个实时系统能够使用RM调度模型，那么有：<span style="font-weight: bold;">  </span></div><div><span style="font-weight: bold;">                                                                 <img src="建模复习——从入门到放弃_files/Image [7].png" type="image/png" data-filename="" style="font-weight: bold;" width="136"/> </span></div><div><span style="font-weight: bold;">       </span> 如，对于周期任务  T1(4,1)，T2(5,1)，T3(10,1)，有：</div><div>                                                                                   <img src="建模复习——从入门到放弃_files/Image [8].png" type="image/png" data-filename="" width="222"/></div><div>         因此，以上三个任务是能够被RM模型调度的。</div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">4.3 EDF（最早截止时间优先，<span style="font-weight: bold;">Earliest Deadline First</span></span><span style="font-weight: bold;">）调度算法</span></div><div><br/></div><div><span style="font-weight: bold;">  </span> <span style="font-weight: bold;"> </span><span style="font-weight: bold;">4.3.1 调度算法描述</span></div><div><ul><li><span style="background-color: rgb(255, 250, 165); line-height: 1.45;-evernote-highlight:true;">最佳的动态优先级调度</span></li><li><span style="background-color: rgb(255, 250, 165); line-height: 1.45;-evernote-highlight:true;">具有较早截止时间的任务具有较高的优先级</span></li><li><span style="line-height: 1.45;">以最早的截止时间执行任务</span></li></ul><div><span style="line-height: 1.45;">  </span></div></div><div><br/></div><div><span style="line-height: 1.45;">    <span style="line-height: 1.45; font-weight: bold;">4.3.2 调度过程</span></span></div><div style="text-align: center;"><div><span style="font-weight: bold;"> <img src="建模复习——从入门到放弃_files/Image [9].png" type="image/png" data-filename="" style="font-weight: bold;" width="630"/></span><span style="line-height: 1.45;">  </span></div></div><div style="text-align: center;"><span style="line-height: 1.45;">图4.2.2-1：EDF调度过程示意图</span></div><div style="text-align: left;"><div><br/></div></div><div><br/></div></div><div><span style="font-weight: bold;">    4.3.3 EDF调度模型使用限制</span></div><div>           如果一个实时系统可以使用EDF算法进行调度，则有： <span style="line-height: 1.45;">∑Ui ≤ 1</span></div><div><br/></div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">4.4 实时操作系统</span></div><div><span style="font-weight: bold;">   </span></div><div><span style="font-weight: bold;">    </span><span style="font-weight: bold;">4.4.1 实时操作系统简介</span></div><div>           PRET-C，Nucleus Real Time Operating System (RTOS)；</div><div>            注：详见  2.safety-critical system.ppt （p85~p95）</div><div>    </div><div><span style="font-weight: bold;">  </span> <span style="font-weight: bold;"> </span><span style="font-weight: bold;">4.4.2 实时操作系统特点</span></div><div><span style="font-weight: bold;">    </span></div><div>      实时操作系统内核的实时性能定量指标包括</div><div><ul><li><span style="line-height: 1.45;">任务上下文切换时间 ：中断延迟，响应，恢复时间，任务响应时间</span></li><li><span style="line-height: 1.45;">最大中断禁止时间：反映内核对外界停止中断响应的最长时间</span></li><li>任务上下文切换时间：系统中最频繁发生的动作，影响整个系统性能</li></ul><div><span style="line-height: 1.45;">          包括：保存当前任务上下文、选择新任务，及恢复新任务上下文三个阶段</span></div></div><div><br/></div><div><br/></div><div>      提高内核实时性的方法：任务互斥、同步</div><div><ul><li><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">资源有限等待</span>：任务没能获得需要的资源会被阻塞。如果资源不是任务继续运行必备的，任务可选择有限等待该资源</li><li><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">优先级反转问题解决</span>：抢占式任务调度中的资源竞争，采用优先级继承协议消除</li></ul><div>          多任务内核应允许动态改变任务的优先级以避免发生优先级反转现象。</div><div>          为防止发生优先级反转,内核能自动变换任务的优先级,这叫做优先级继承(Priority inheritance)。详见 <a href="http://blog.csdn.net/thl789/article/details/617629" style="font-style: italic;">优先级反转和优先级继承</a> </div></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">5 . UML建模（M<span style="font-size: 12pt; font-weight: bold;">odeling with UML</span></span><span style="font-size: 12pt; font-weight: bold;">）</span></div><div><br/></div><div><span style="font-size: 10pt; font-weight: bold; line-height: 1.45;">    参考资料：</span></div><div><ul><li><a href="https://www.ibm.com/developerworks/cn/rational/r-uml/" style="font-style: italic;">UML基础: 统一建模语言简介</a></li><li><a href="https://www.cnblogs.com/shindo/p/5579191.html" style="font-style: italic;">五分钟读懂UML类图</a></li><li><a href="http://www.uml.org.cn/oobject/201609092.asp" style="font-style: italic;">UML实践详细经典教程</a></li><li><a href="http://www.woshipm.com/pd/555549.html" style="font-style: italic;">活动图实例：细谈UML建模语言中的活动图模型</a></li><li><a href="https://www.cnblogs.com/ywqu/archive/2009/12/14/1624082.html" style="font-style: italic;">UML建模之活动图介绍</a><span style="font-style: italic;"> </span></li><li><a href="https://www.cnblogs.com/silent2012/archive/2011/09/14/2172219.html" style="color: rgb(0, 0, 238); font-style: italic; text-decoration: underline;">UML学习（三）-----序列图</a> </li><li><a href="http://www.sparxsystems.cn/resources/uml2_tutorial/uml2_timingdiagram.html" style="font-style: italic;">UML 2.0 时间图</a></li><li>4.modeling with UML（requirement）.ppt </li></ul><div><br/></div></div><div><br/></div><div><span style="font-weight: bold;">5.1 用例图（</span><span style="font-weight: bold;">Use case diagrams</span><span style="font-weight: bold;">），类图（</span><span style="font-weight: bold;">Class diagrams</span><span style="font-weight: bold;">），</span></div><div><span style="font-weight: bold;">     序列图（</span><span style="font-weight: bold;">Sequence diagrams</span><span style="font-weight: bold;">）和状态图（</span><span style="font-weight: bold;">State diagrams</span><span style="font-weight: bold;">）</span></div><div><ul><li><span style="line-height: 1.45;">用例图：描述用户所看到的系统的功能行为，用例图从用户的角度来表示系统的功能（</span><span style="background-color: rgb(255, 250, 165); line-height: 1.45;-evernote-highlight:true;">静态视图</span><span style="line-height: 1.45;">）</span></li><li><span style="line-height: 1.45;">类图：描述系统的</span><span style="background-color: rgb(255, 250, 165); line-height: 1.45;-evernote-highlight:true;">静态结构</span><span style="line-height: 1.45;">（对象，属性，联系），类图表示系统的结构</span></li><li><span style="line-height: 1.45;">序列图：描述系统对象之间的</span><span style="background-color: rgb(255, 250, 165); line-height: 1.45;-evernote-highlight:true;">动态行为</span><span style="line-height: 1.45;">，序列图将系统的行为表示为不同对象之间的消息交互</span></li><li><span style="line-height: 1.45;">状态图：描述单个对象的</span><span style="background-color: rgb(255, 250, 165); line-height: 1.45;-evernote-highlight:true;">动态行为</span><span style="line-height: 1.45;">，用有趣的动态行为来表示单个对象的行为</span></li></ul><div><br/></div></div><div><br/></div><div><span style="font-weight: bold;">5.2 行为建模</span></div><div><span style="font-weight: bold;">   </span> 从逻辑上讲，可以将单个元素或元素组的行为建模为三种不同类型：（详见  4.modeling with UML.ppt p72~p82）</div><div><ul><li>简单行为</li><li>状态行为</li><li>持续行为</li></ul></div><div><br/></div><div><span style="font-size: 10pt;">    其他非功能性限制也经常适用。这种约束被称为QOS约束，完成这一行为的质量。</span></div><div><span style="font-size: 10pt;">    例如：一个动作需要多长时间？两位数的准确度足够了吗？</span><span style="font-size: 10pt; line-height: 1.45;">QOS约束通常使用约束语言进行建模（OCL）。</span></div><div><br/></div><div><span style="font-size: 10pt; line-height: 1.45;">    UML的主要特征是支持有限状态机。</span><span style="line-height: 1.45;">状态图的两个基本概念是</span><span style="background-color: rgb(255, 250, 165); line-height: 1.45;-evernote-highlight:true;">状态和转换</span><span style="line-height: 1.45;">。</span></div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">5.3 状态图（state chart）</span></div><div><span style="font-weight: bold;">   </span>状态的特点：</div><div>    可以在状态图上捕获行为的对象被认为是被动的。</div><div>    这样一个对象的行为空间被分解为存在的不相交和不相交的条件，称为状态。</div><div>    转换是对导致状态改变的事件的响应。<span style="line-height: 1.45;">该对象可以在接收到事件（尽管不进行转换）或者进行转换时执行动作，进入或退出状态。</span></div><div><br/></div><div><span style="line-height: 1.45;">    UML中定义了四种事件：</span></div><div><ul><li>SignalEvent：与信号相关的事件。</li></ul><div><span style="line-height: 1.45;">          Signal是一个</span><span style="background-color: rgb(255, 250, 165); line-height: 1.45;-evernote-highlight:true;">异步通信</span><span style="line-height: 1.45;">的规范，所以SignalEvent是一个与异步接收信号相关的事件。</span></div></div><div><ul><li>CallEvent：与调用相关联的事件。</li></ul><div><span style="line-height: 1.45;">          Call是一个</span><span style="background-color: rgb(255, 250, 165); line-height: 1.45;-evernote-highlight:true;">同步通信</span><span style="line-height: 1.45;">的规范，所以CallEvent允许一个对象直接调用其中一个方法来影响另一个对象的状态。</span></div></div><div><ul><li>TimeEvent：与时间流逝相关的事件，通常用tm（&lt;duration&gt;）或after（&lt;duration&gt;）表示。</li></ul></div></div></div><blockquote style="margin: 0px 0px 0px 40px; border: none; padding: 0px;"><div style="text-align: left;"><div><span style="line-height: 1.45;">几乎所有的TimeEvents都是相对的时间。也就是说，它们指定事件将在对象处于指定状态至少&lt;duration&gt;时间单位后发生。</span></div><div><span style="line-height: 1.45;">如果对象在超时之前离开该状态，则与该持续时间关联的逻辑计时器将消失，而不会创建超时事件</span></div></div></blockquote><ul><li>ChangeEvent：与属性的值更改关联的事件。</li></ul><blockquote style="margin: 0px 0px 0px 40px; border: none; padding: 0px;"><div><span style="line-height: 1.45;">它很少用在软件应用程序中。然而，当一个状态属性被内存映射到一个硬件上时，它可以用来指示内存地址改变的值</span></div><div><br/></div></blockquote><div style="text-align: left;"><div><br/></div><div>     转换（transition）</div><div>     转换是从起始状态开始并在目标状态结束的弧。 </div><div>     转换通常具有命名的事件触发器，可选地随后是执行转换时执行的动作（即可执行语句或操作）。</div><div>      过渡事件签名的格式为：</div><div>              event-name '(' parameter-list ')' '[' guard-expression ']' '/' action-list</div><div>              注：事件可以指定形式参数列表，这意味着事件可以携带实际的参数。</div><div>              digit(key: keyType)/ show(key)</div><div><br/></div><div>    约束（Guard）和行为执行顺序（Execution Order）：</div><div>    guard表达式是一个布尔表达式，包含在方括号中，必须计算为true或false。</div><div>    行动的执行顺序很重要，基本规则是退出-&gt;转换-&gt;进入（exit-transition-entry）。</div><div>    也就是说，先行状态的退出动作首先执行，然后是转换动作，随后是后续状态的进入动作。</div><div><br/></div><div>    注：Guard的原意为“保卫，守卫”，根据实际意义暂译为“约束”，不一定准确。</div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">5.4 状态机（state chart）</span></div><div><br/></div><div> 伪状态（Pseudostates）符号表示，<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">历史伪状态（History）</span>：详见  4.modeling with UML.ppt p91~p98</div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">5.5 活动图（Activity Diagrams）</span></div><div><br/></div></div></div><blockquote style="margin: 0px 0px 0px 40px; border: none; padding: 0px;"><div style="text-align: left;"><div>UML 1.x中的活动图在语义上等同于状态图，并共享一个通用的元模型。 </div></div><div style="text-align: left;"><div>在UML 2.0中，活动图给出了独立于状态图的语义基础。 在UML 2.0中，有多个级别的活动图：基本的，中间的，完整的等等。</div></div><div style="text-align: left;"><div>详见  4.modeling with UML.ppt p99~p104</div></div></blockquote><div style="text-align: left;"><div><br/></div></div><blockquote style="margin: 0px 0px 0px 40px; border: none; padding: 0px;"><div style="text-align: left;"><div>活动图元素：</div></div><div style="text-align: left;"><div>1、活动状态图（Activity）                                        2、动作状态（Actions)</div></div><div style="text-align: left;"><div>3、动作状态约束（Action Constraints）                    4、动作流（Control Flow）</div></div><div style="text-align: left;"><div>5、开始节点（Initial Node）                                     6、终止节点（Final Node）</div></div><div style="text-align: left;"><div>7、对象（Objects）                                                 8、数据存储对象（DataStore）</div></div><div style="text-align: left;"><div>9、对象流（Object Flows）                                      10、分支与合并（Decision and Merge Nodes）</div></div><div style="text-align: left;"><div>11、分叉与汇合（Fork and Join Nodes）                 12、异常处理（Exception Handler）</div></div><div style="text-align: left;"><div>13、活动中断区域（Interruptible Activity Region）    14、泳道（Partition）</div></div></blockquote><div style="text-align: left;"><div><br/></div></div><blockquote style="margin: 0px 0px 0px 40px; border: none; padding: 0px;"><div style="text-align: left;"><div>    UML中有三种主要的图形式来描述交互场景 ：</div></div></blockquote><div style="text-align: left;"><div><ul><li><span style="line-height: 1.45;">交互图（communication diagrams）</span></li><li><span style="line-height: 1.45;">序列图（sequence diagrams）</span></li><li><span style="line-height: 1.45;">时序图（timing diagrams）</span></li></ul><div><br/></div></div><div><br/></div><div><span style="font-weight: bold;">5.6 序列图（<span style="font-weight: bold;">Sequence Diagrams）</span></span></div></div><blockquote style="margin: 0px 0px 0px 40px; border: none; padding: 0px;"><div style="text-align: left;">序列图：详见 参考资料 <a href="https://www.cnblogs.com/silent2012/archive/2011/09/14/2172219.html" style="font-style: italic;">UML学习（三）-----序列图</a></div><div style="text-align: left;"><div>序列图<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">局部顺序的确定</span> ，如作业exercise中的第二题。</div></div><div style="text-align: left;">序列图中的循环</div><div style="text-align: left;"><br/></div></blockquote><div><span style="font-weight: bold;">5.7 时间图（<span style="font-weight: bold;">Timing </span></span><span style="font-weight: bold;">Diagrams）</span></div><blockquote style="margin: 0px 0px 0px 40px; border: none; padding: 0px;"><div>时间图： 详见参考资料  <a href="http://www.sparxsystems.cn/resources/uml2_tutorial/uml2_timingdiagram.html" style="font-style: italic;">UML 2.0 时间图</a></div><div>值生命线（Value lifeline）和状态生命线( State lifeline)</div><div><br/></div></blockquote><div><br/></div><div><br/></div><div><span style="font-weight: bold;">5.8 时间自动机（<span style="font-weight: bold;">Timed automata</span></span><span style="font-weight: bold;">）</span></div><div><span style="line-height: 1.45;">        时间自动机是实时系统建模与验证的理论。 具有相同目的的其他形式的例子还有</span><span style="line-height: 1.45;">时间Petri网（timed Petri Nets）</span><span style="line-height: 1.45;">，</span></div><div><span style="line-height: 1.45;">        时间过程代数（timed process algebras）和实时逻辑（real time logics）</span></div><div style="text-align: left;"><div>        公平地说，以时间自动机作为输入语言的核心开发的几种模型检查器是理论应用和发展的动力。</div><div><br/></div><div>        时间自动机本质上是一个用实值变量（时间系统）进行扩展的有限自动机（包含一组有限节点和一组有限带有标记的边的图）</div><div><ul><li><span style="line-height: 1.45;"><span style="background-color: rgb(255, 250, 165); line-height: 1.45;-evernote-highlight:true;">变量（variables）</span>对系统中的逻辑时钟进行建模，在系统启动时用零初始化，然后以相同的速率同步增加</span></li><li><span style="line-height: 1.45;"><span style="background-color: rgb(255, 250, 165); line-height: 1.45;-evernote-highlight:true;">时钟约束（clock constraints）</span>，即边上用于限制自动机行为的<span style="background-color: rgb(255, 250, 165); line-height: 1.45;-evernote-highlight:true;">约束（Guard）</span></span></li><li><span style="line-height: 1.45;">当时钟值满足在边上标记约束（Guard）时，边表示的</span><span style="background-color: rgb(255, 250, 165); line-height: 1.45;-evernote-highlight:true;">转换（transition）</span><span style="line-height: 1.45;">就可以发生。 当进行转换时，时钟可能被重置为零。</span></li></ul><div><br/></div></div><div style="text-align: center;"><img src="建模复习——从入门到放弃_files/Image [10].png" type="image/png" data-filename="" style="line-height: 1.45;" width="346"/><br/></div><div style="text-align: center;">图5.8-1：时间自动机示例图</div><div style="text-align: left;"><br/></div><div style="text-align: left;">       时间自动机语法：Review.ppt p<span style="line-height: 1.45;">96</span></div><div style="text-align: left;"><div><br/></div></div><div style="text-align: left;"><span style="line-height: 1.45;">       时间自动机工具UPPAAL</span></div><div style="text-align: left;"><ul><li><span style="line-height: 1.45;">同步通信（synchronous）通过使用输入输出行为的握手同步（hand-shake synchronization）来实现</span></li><li><span style="line-height: 1.45;">异步通信（asynchronous）使用共享变量（shared variables）来实现</span></li></ul><div><br/></div><div>       为了对握手同步进行建模，字母 ∑ 定义为包括：输入动作 a？，输出动作a！，内部行为 ‘T’</div></div><div style="text-align: left;"><div><br/></div></div><div style="text-align: left;"><div>      时间自动机示例：铁路交叉口控制系统的建模与验证：Review.ppt p101~p103</div></div><div style="text-align: left;"><div><br/></div></div><div style="text-align: left;"><div><br/></div></div><div style="text-align: left;"><div><br/></div></div><div style="text-align: left;"><div><span style="font-weight: bold;">5.9 UML 预定义包（UML profile</span><span style="font-weight: bold;">）</span></div></div><div style="text-align: left;"><div><br/></div></div><div style="text-align: left;">        一个UML预定义包是一个扩充具有补充信息的UML模型的工具。 这种机制可以以两种方式使用：</div><div style="text-align: left;"><ul><li><span style="line-height: 1.45;">用以扩展UML语言。</span></li></ul><div><span style="line-height: 1.45;">          例如，UML没有提供明确的信号量概念，但可以通过重载现有的UML概念（如Class）来添加它。</span></div></div><div style="text-align: left;"><div><span style="line-height: 1.45;">          结果是一种特殊的类，它除了标准的类语义之外，还包含信号量语义。</span></div><ul><li><span style="line-height: 1.45;">可用于将附加信息附加到辅助用途（如模型分析或代码生成）所需的模型。 </span></li></ul><div><span style="line-height: 1.45;">          例如，可以使用这种注释来指定类的某些操作的最差情况执行时间，这可能需要用于分析应用程序的时序特性。</span></div></div><div style="text-align: left;"><div><br/></div></div><div style="text-align: left;"><span style="line-height: 1.45;">      TimedObservation是TimedInstantObservation和TimedDurationObservation的抽象超类。 </span></div><div style="text-align: left;"><div><span style="line-height: 1.45;">      TimedInstantObservation表示与事件发生（eocc属性）相关联并且在给定时钟上观察到的时刻。</span></div><div><span style="line-height: 1.45;"><br/></span></div><div><span style="line-height: 1.45;"><span>    <span>    UML预定义包的优点：</span></span><br/></span></div><div><ul><li><span style="line-height: 1.45;">语言基础设施的再利用（工具，规格）</span><br/></li><li><span style="line-height: 1.45;">需要较少的语言设计技能</span><br/></li><li><span style="line-height: 1.45;">允许扩展构造型采用新（图形）符号</span><br/></li><li><span style="line-height: 1.45;">配置文件可以定义模型视点</span><br/></li></ul><div><br/></div></div><div><span>    <span>   缺点：受UML元模型的约束</span></span><br/></div><div><span style="line-height: 1.45;"><br/></span></div><div><span style="line-height: 1.45;"><span>    <span>   注：至今未找到关于UML profile 的准确翻译，参考了一下网上的几种说法，感觉“预定义包”的说法相对较为准确。</span></span><br/></span></div><div><span style="line-height: 1.45;"><span><span>       链接如下：<a href="http://www.umlchina.com/best/g28/u1135848.htm"><i>UML中的profile翻译成什么中文比较恰当？</i></a></span><br/></span></span></div></div><div style="text-align: left;"><div><br/></div></div><div style="text-align: left;"><div><br/></div></div><div style="text-align: left;"><div>      </div></div><div style="text-align: left;"><br/></div><div style="text-align: left;"><br/></div><div style="text-align: left;"><br/></div><div style="text-align: left;"><br/></div><div style="text-align: left;"><br/></div><div style="text-align: left;"><div><span style="font-size: 12pt; font-weight: bold;">5 . 设计阶段（<span style="font-size: 12pt; font-weight: bold;">Design Phase</span></span><span style="font-size: 12pt; font-weight: bold;">）</span></div></div><div style="text-align: left;"><div>      <b> 参考资料：</b>4.modeling with UML（design）.ppt</div><div><br/></div><div><br/></div></div><div style="text-align: left;"><ul><li><span style="line-height: 1.45;">架构设计（Architectural design）详细介绍了最大的软件结构，如子系统，软件包和任务</span></li><li><span style="line-height: 1.45;">机械设计（Mechanistic design）包括共同努力实现共同目标的类</span></li><li><span style="line-height: 1.45;">详细设计（Detailed design）指定了各个类内部的原始数据结构和算法</span></li></ul></div></div><div style="text-align: left;"><div>      表格中详细描述了三个类别：</div><div style="text-align: center;"><img src="建模复习——从入门到放弃_files/Image [11].png" type="image/png" data-filename="" width="728"/></div><div style="text-align: center;">图5-1：三个层次的设计类别</div><div style="text-align: left;">       </div><div style="text-align: left;">    Notice:</div><div style="text-align: left;"><ul><li><span style="line-height: 1.45;">对于简单的系统，大部分的设计工作可能会花在机械和细节层面。</span></li><li><span style="line-height: 1.45;">对于包括航空电子设备和其他分布式实时系统在内的大型系统而言，架构级别设计对项目成功至关重要。</span></li><li>4.modeling with UML（design）.ppt 中主要讲的是架构层次的设计 </li></ul></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">6 . 后记</span></div><div><span style="font-size: 12pt; font-weight: bold;"><span>    </span></span></div></div></div><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"><div style="text-align: left;"><div><span style="font-size: 10pt; line-height: 1.45;">本文主要整理自复习课上的ppt（Review.ppt），由于本人水平一般，能力有限，文中不当乃至谬误之处恐在所难免，</span></div><div><span style="font-size: 10pt; line-height: 1.45;">尤其是部分内容的翻译，以及最后MARTE建模与设计模式部分，实在参不透那几张ppt上的意思（唯一能做的，就是</span></div><div><span style="font-size: 10pt; line-height: 1.45;">双手合十，祈祷不会考，</span><span style="font-size: 10pt; line-height: 1.45;">如果有会的大佬，望不吝赐教），为</span><span style="font-size: 10pt; line-height: 1.45;">避免出现误导，所以索性略过。仅以此文抛砖引玉。</span></div><div><span style="font-size: 10pt; line-height: 1.45;"><br/></span></div><div><span style="font-size: 10pt; line-height: 1.45;">行文至此，自然是致谢。</span></div></div></blockquote><ul><li><span style="font-size: 10pt; line-height: 1.45;"><span style="font-size: 10pt; line-height: 1.45;">感谢陈博老师几个月来的辛勤授课，并在最后一节课组织了答疑，尽管我什么也没听到（被堵在人群之外，</span><span style="font-size: 10pt; line-height: 1.45;">根本就</span><br/></span></li></ul><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"><div style="text-align: left;"><div><span style="font-size: 10pt; line-height: 1.45;">没能凑过去）。</span></div></div></blockquote><ul><li><span style="line-height: 19px;">感谢崔宇鑫同学提供复习课全程录音，路转粉，给小姐姐打call，祝好人一生平安。</span></li></ul><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"><span style="line-height: 19px;"><span style="line-height: 19px;"><br/>
最后，一首腾格尔的<a href="https://www.bilibili.com/video/av16068697/?from=search&amp;seid=14083153877221136778"><i>《隐形的翅膀》</i></a>送给大家，祝大家节日快乐，考试顺利！<br/></span><br/><span>  </span>雷杨<br/>
 2017年11月11日<span style="line-height: 19px;"><br/><br/></span></span></blockquote><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"><div style="text-align: left;"><div><span style="font-size: 10pt; line-height: 1.45;"><br/></span></div></div></blockquote><div style="text-align: left;"><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></div><div style="text-align: center;"><div><br/></div></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></div></span>
</div></body></html> 